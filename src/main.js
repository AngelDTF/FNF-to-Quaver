const Readline = require('readline').createInterface({"input":process.stdin, "output":process.stdout});
const FS = require('fs');
const Path = require('path');

const Package = require('../package.json');

let mode = 3;

Readline.question('Path to FNF Chart JSON:\n', answer =>
{
	let path = Path.parse(answer.trim());
	let data = FS.readFileSync(Path.format(path).trimQuotes(), {"encoding":"utf8"});
	console.log('\n*** Original Data: ***\n' + data);
	Readline.question('\nSelect a mode: 1 = BF Only | 2 = Opponent Only | 3 = Both\n', answer =>
	{
		mode = parseInt(answer);
		parseJson(JSON.parse(data), path.name);
		process.exit(0);
	});
});

function parseJson(object, name = 'output')
{
	let song = object.song;
	let sections = song.notes;
	let kv = new String();

	kv = kv.addLine(`AudioFile: audio.mp3`);
	kv = kv.addLine(`BackgroundFile: ''`);
	kv = kv.addLine(`MapId: -1`);
	kv = kv.addLine(`MapSetId: -1`);
	kv = kv.addLine(`Mode: Keys4`);
	kv = kv.addLine(`Title: ${song.song}`);
	kv = kv.addLine(`Artist: FNFtQ`);
	kv = kv.addLine(`Source: Friday Night Funkin`);
	kv = kv.addLine(`Tags: FNF,Funkin`);
	kv = kv.addLine(`Creator: FNFtQ`);
	kv = kv.addLine(`DifficultyName: ${getDiff(song.song, name)}`);
	kv = kv.addLine(`Description: Generated by FNF-to-Quaver v${Package.version}`);
	kv = kv.addLine(`EditorLayers: []`);
	kv = kv.addLine(`CustomAudioSamples: []`);
	kv = kv.addLine(`SoundEffects: []`);
	kv = kv.addLine(`TimingPoints:`);
	kv = kv.addLine(`-  Bpm: ${song.bpm}`);
	kv = kv.addLine(`SliderVelocities: []`);
	kv = kv.addLine(`HitObjects:`);
	for (let i = 0; i < song.notes.length; i++)
	{
		if (sections[i].sectionNotes == undefined)
			continue;

		for (let n = 0; n < sections[i].sectionNotes.length; n++)
		{
			var strumtime = sections[i].sectionNotes[n][0];
			var notedata = sections[i].sectionNotes[n][1];
			var suslength = sections[i].sectionNotes[n][2];

			// mode checks
			if (mode == 1 && ((sections[i].mustHitSection && notedata > 3) || (!sections[i].mustHitSection && notedata < 4)))
				continue;
			else if (mode == 2 && ((!sections[i].mustHitSection && notedata > 3) || (sections[i].mustHitSection && notedata < 4)))
				continue;
			
			// convert to quaver notes
			kv = kv.addLine(`- StartTime: ${Math.round(strumtime)}`);
			kv = kv.addLine(`  Lane: ${(notedata % 4) + 1}`);
			if (suslength > 1)
				kv = kv.addLine(`  EndTime: ${Math.round(strumtime + suslength)}`);
			kv = kv.addLine(`  KeySounds: []`);
		}
	}
	if (kv.endsWith('HitObjects:')) kv += ' []'; // if nothing was added
	console.log('\n*** New Data: ***\n' + kv);
	console.log(`\nOutputting to "${name}.qua"...`);
	if (!FS.existsSync('./output')) FS.mkdirSync('./output');
	FS.writeFileSync(`./output/${name}.qua`, kv);
}

function getDiff(songname, filename)
{
	songname = songname.toLowerCase().replace(/ /g, '-').trim();
	filename = filename.toLowerCase().trim();

	if (songname != filename)
	{
		if (filename.indexOf(songname + '-') == 0)
		{
			let diff = filename.splitAtFirst(songname + '-')[1].split('-');
			for (var i = 0; i < diff.length; i++)
				diff[i] = diff[i][0].toUpperCase() + diff[i].substring(1).toLowerCase();
			return diff.join(' ');
		}
		else // fallback
		{
			if (filename.endsWith('-easy'))
				return 'Easy';
			if (filename.endsWith('-hard'))
				return 'Hard';
		}
	}
	return 'Normal';
}

String.prototype.addLine = function(str)
{
	return this + (this.length > 1 ? '\n' : '') + str;
};

String.prototype.trimQuotes = function()
{
	let str = this.valueOf();
	if (str.startsWith('"')) str = str.substring(1);
	if (str.endsWith('"')) str = str.slice(0, -1);
	return str;
};

String.prototype.splitAtFirst = function(splitter)
{
	if (!this.includes(splitter)) return [this.toString()];
	var rest = this.split(splitter);
	rest.shift();
	return [this.split(splitter)[0], rest.join(splitter)];
}